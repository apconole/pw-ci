#!/bin/sh
# SPDX-Identifier: gpl-2.0-or-later
# Copyright (C) 2018, Red Hat, Inc.
#
# Monitors a project on a patchwork instance for new series submissions
# Records the submissions in the series database (and emits them on the
# stdout line for processing)
#
# Licensed under the terms of the GNU General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.  You may obtain a copy of the
# license at
#
#    https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

[ -f "${HOME}/.pwmon-rc" ] && source "${HOME}/.pwmon-rc"

if [ "$1" != "" ]; then
    pw_project="$1"
    shift
fi

if [ "$1" != "" ]; then
    pw_instance="$1"
    shift
fi

if [ "X$pw_instance" == "X" -o "X$pw_project" == "X" ]; then
   echo "ERROR: Patchwork instance and project are unset."
   echo "Please setup ${HOME}/.pwmon-rc and set pw_project "
   echo "(or pass it as an argument)."
   echo "Also either setup pw_instance or pass it as an argument."
   exit 1
fi

userpw=""

if [ "$1" != "" ]; then
    pw_credential="$1"
fi

if [ "X$pw_credential" != "X" ]; then
   userpw="-u \"${pw_credential}\""
fi

source $(dirname $0)/series_db_lib.sh

function emit_series() {
    local instance="$1"
    local project="$2"
    local id="$3"
    local url="$4"
    local submitter_name="$5"
    local submitter_email="$6"
    local all="$7"
    local completed=0

    if [ "$all" = "true" ]; then
        completed=1
    fi

    if ! series_id_exists "${instance}" "${id}"; then
        echo "============================================="
        echo "Series instance: $instance"
        echo "Series id:       $id"
        echo "Series url:      $url"
        echo "submitter:       $submitter_name <$submitter_email>"
        echo "all:             $all"
        echo "recording series (${id}, \"${url}\", \"${submitter_name}\", \"${submitter_email}\")"
        echo

        series_db_add_false "$instance" "$project" "$id" "$url" "$submitter_name" "$submitter_email" "$completed"
    else
        echo "series ${id} exists"
    fi
}

function check_new_series() {

    local INSTANCE="$1"
    local PROJECT="$2"

    if [ "$PROJECT" == "" -o "$INSTANCE" == "" ]; then
        echo "ERR: need a project"
        exit 1
    fi

    if [ ! -e "${HOME}/.pwmon-${INSTANCE}-${PROJECT}-series" ]; then
        echo "WARN: PW-series doesn't exist..."
        echo "      Re-running with patches since yesterday"
        TRY_DATE=$(date --date="yesterday" '+%F %T')
        STAMP_DATE=$(date --date="$TRY_DATE + 1 day")
    else
        TRY_DATE=$(stat "${HOME}/.pwmon-${INSTANCE}-${PROJECT}-series" | grep Modify | cut -d" " -f2-3 | cut -d. -f1)
        STAMP_DATE=$(date)
    fi

    STAMP=$(date --date="$STAMP_DATE" '+%C%y%m%d%H%M')
    SINCE=$(date --date="$TRY_DATE" '+%F %T' | sed -e 's@ @+@' -e 's@:@%3A@g')
    BEFORE=$(date --date="$STAMP_DATE" '+%F %T' | sed -e 's@ @+@' -e 's@:@%3A@g')

    GET_URL="http://${INSTANCE}/api/events/?category=series-completed&since=${SINCE}&before=${BEFORE}"
    response=$(curl -s "$userpw" "$GET_URL")

    series_info=$(echo "$response" | jq -rc ".[] | select(.project.link_name == \"${PROJECT}\") | (.payload.series.id|tostring) + \";\" + .payload.series.url + \";\"")

    if [ "X$series_info" != "X" ]; then
        echo "$series_info" | while IFS=\; read -r id url; do
            all=1
            series_author=$(curl -s "$userpw" "$url")
            submitter_name=$(echo "$series_author" | jq '.submitter.name')
            submitter_email=$(echo "$series_author" | jq '.submitter.email')
            emit_series "${INSTANCE}" "${PROJECT}" "$id" "$url" "$submitter_name" "$submitter_email" "$all"
        done
    fi

    touch -m -t "${STAMP}" "${HOME}/.pwmon-${INSTANCE}-${PROJECT}-series"
}

function check_completed_series() {
    get_uncompleted_jobs_as_line "$pw_instance" "$pw_project" | while IFS=\| read -r id url submitter_name submitter_email; do
        echo "Checking on series: $id"
        local RESPONSE=$(curl -s "$userpw" "$url" | jq -rc '.received_all')
        if [ "$RESPONSE" = "true" ]; then
            echo "Setting series $id to completed"
            series_id_set_complete "$pw_instance" "$id"
        fi
    done
    return 0
}

function check_undownloaded_series() {
    get_undownloaded_jobs_as_line "$pw_instance" "$pw_project" | while IFS=\| read -r id url submitter_name submitter_email; do
        echo "re-submitting series: $id"
        series_id_clear_downloaded "$pw_instance" "$id"
    done
    return 0
}

function check_superseded_series() {
    local pw_instance="$1"
    series_get_active_branches "$pw_instance" | while IFS=\| read -r series_id project url repo branchname; do
        # first query the patch states
        local last_patch_url=$(curl -s "$userpw" "$url" | jq -rc '.patches[-1].url')
        local patch_state=$(curl -s "$userpw" "$last_patch_url" | jq -rc '.state')

        # now check to see if the patch should even be reported...
        if [ "$patch_state" = "superseded" -o "$patch_state" = "rejected" -o "$patch_state" = "accepted" \
             -o "$patch_state" = "changes-requested" -o "$patch_state" = "not-applicable" ]; then
            series_clear_branch "$pw_instance" "$series_id"
            set_synced_for_series "$series_id" "$pw_instance"
        fi
        echo "Worked on $series_id : state $patch_state"
    done
}

check_undownloaded_series "$pw_instance" "$pw_project"
check_completed_series "$pw_instance" "$pw_project"
check_new_series "$pw_instance" "$pw_project"
check_superseded_series "$pw_instance"
